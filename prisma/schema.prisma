generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  password      String?
  name          String
  phone         String?
  avatar        String?
  role          UserRole  @default(USER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  accounts      Account[]
  bookings      Booking[]
  sessions      Session[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Route {
  id              String     @id @default(cuid())
  from            String
  to              String
  price           Int
  duration        String
  busType         String
  distance        String?
  description     String?
  routeMapImage   String?
  thumbnailImage  String?
  images          Json?
  fromLat         Float?
  fromLng         Float?
  toLat           Float?
  toLng           Float?
  operatingStart  String
  operatingEnd    String
  intervalMinutes Int        @default(30)
  isActive        Boolean    @default(true)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  bookings        Booking[]
  schedules       Schedule[]

  @@map("routes")
}

model Schedule {
  id             String    @id @default(cuid())
  routeId        String
  busId          String
  date           DateTime
  departureTime  String
  availableSeats Int
  totalSeats     Int
  status         String    @default("ACTIVE")
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  bookings       Booking[]
  bus            Bus       @relation(fields: [busId], references: [id], onDelete: Cascade)
  route          Route     @relation(fields: [routeId], references: [id], onDelete: Cascade)

  @@unique([routeId, busId, date, departureTime])
  @@map("schedules")
}

model Bus {
  id           String     @id @default(cuid())
  licensePlate String     @unique
  busType      String
  totalSeats   Int
  status       String     @default("ACTIVE")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  schedules    Schedule[]

  @@map("buses")
}

model Booking {
  id            String        @id @default(cuid())
  bookingCode   String        @unique
  userId        String?
  customerName  String
  customerPhone String
  customerEmail String?
  routeId       String
  scheduleId    String?
  date          DateTime
  departureTime String
  seats         Int           @default(1)
  totalPrice    Int
  status        BookingStatus @default(PENDING)
  qrCode        String?
  ticketUrl     String?
  checkedIn     Boolean       @default(false)
  checkedInAt   DateTime?
  checkedInBy   String?
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  route         Route         @relation(fields: [routeId], references: [id])
  schedule      Schedule?     @relation(fields: [scheduleId], references: [id])
  user          User?         @relation(fields: [userId], references: [id])
  payment       Payment?

  @@map("bookings")
}

model Payment {
  id            String        @id @default(cuid())
  bookingId     String        @unique
  amount        Int
  method        PaymentMethod
  status        PaymentStatus @default(PENDING)
  transactionId String?
  paidAt        DateTime?
  metadata      Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  booking       Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("payments")
}

enum UserRole {
  USER
  STAFF
  ADMIN
}

enum BookingStatus {
  PENDING
  CONFIRMED
  PAID
  CANCELLED
  COMPLETED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  QRCODE
  VNPAY
  MOMO
}
